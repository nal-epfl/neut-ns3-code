//
// Created by nal on 20.10.21.
//
// Network topology
//
//                            +--- d0
//      s0 ---+-- r0 ___ r1 --+--- d1
//                            +--- d2
//
// - All links are P2P
// - Wehe applications runs along d0->s0, d1->s0, d2->s0, and d3->s0
// - Background is CAIDA traces

#include <iostream>
#include <string>
#include <chrono>
#include <random>

#include "ns3/core-module.h"
#include "ns3/network-module.h"
#include "ns3/point-to-point-module.h"
#include "ns3/applications-module.h"
#include "ns3/internet-module.h"
#include "ns3/ipv4-global-routing-helper.h"
#include "ns3/traffic-control-module.h"

#include "ns3/netanim-module.h"
#include "ns3/flow-monitor-module.h"
#include "ns3/file-helper.h"

#include "../monitors_module/PacketMonitor.h"

#include "../traffic_generator_module/trace_replay/MultipleReplayClients.h"
#include "../traffic_generator_module/poisson/PoissonClientHelper.h"
#include "../traffic_generator_module/measurement_replay/MeasurReplayClientHelper.h"
#include "../traffic_generator_module/infinite_tcp/InfiniteTCPClientHelper.h"

#include "../traffic_differentiation_module/CbQueueDisc.h"

using namespace ns3;
using namespace std;
using namespace std::chrono;

NS_LOG_COMPONENT_DEFINE("NeutTest");

#define PCAP_FLAG 0
#define PACKET_MONITOR_FLAG 1

void runRandomControlAndThrottledTraffic(MultipleReplayClients* replayClient,string tracesPath, uint32_t nbTCPFlows, double throttledProb, uint8_t thottledTos, bool splitUdp) {
    vector<string> udpTracesPathNeutral, udpTracesPathThrottled;
    if (splitUdp) {
        udpTracesPathNeutral.push_back(tracesPath + "/UDP/trace_tos0.csv");
        udpTracesPathThrottled.push_back(tracesPath + "/UDP/trace_tos4.csv");
    }
    else {
        udpTracesPathNeutral.push_back(tracesPath + "/UDP/trace_0.csv");
    }

    vector<string> tcpTracesPathNeutral, tcpTracesPathThrottled;

    random_device rd;
    mt19937 mt(rd());
    uniform_real_distribution<double> dist(0.0, 1.0);

    uint32_t countTCP4 = 0;
    for(uint32_t i = 0; i < nbTCPFlows; i++) {
        string tracePath = tracesPath + "/TCP/trace_" + to_string(i) + ".csv";
        if (dist(mt) < throttledProb) {
            countTCP4++;
            tcpTracesPathThrottled.push_back(tracePath);
        }
        else {
            tcpTracesPathNeutral.push_back(tracePath);
        };
    }
    cout << "we have " << countTCP4 << " tcp flows being throttled" << endl;
    replayClient->RunSpecificTraces(tcpTracesPathNeutral, udpTracesPathNeutral, 0);
    replayClient->RunSpecificTraces(tcpTracesPathThrottled, udpTracesPathThrottled, thottledTos);
}

int run_neut_test(int argc, char **argv) {
    auto start = high_resolution_clock::now();

    NS_LOG_INFO("Four Probing applications with CAIDA background is running");

//    LogComponentEnable("InfiniteTCPClient", LOG_LEVEL_ALL);
//    LogComponentEnable("TcpSocketBase", LOG_LEVEL_ALL);

    /*** Defining Inputs: Variables read from arguments ***/
    string commonLinkRate = "180Mbps"; // the transmission rate of the common link
    float duration = 120.; // for how long measurement traffic should run
    string resultsFolderName; // the output folder to save files generated by the monitors
    int isTCP = 0; // 0 to run wehe app as UDP --- 1 to run it as TCP
    string tcpProtocol = "ns3::TcpCubic"; // in case of TCP the congestion control algorithm to use
    uint32_t appType = 0; // the type of measurement application
    uint32_t pktSize = 256; // size of probe packets
    double lambda = 0.001; // rate for constand and lambda for poisson
    string replayTrace = "empty"; // specific traffic to send along the measurement paths
    int isNeutral = 0; // 0 to Run a neutral appType  --- 1 to enable shared policing -- 2 to enable perPath policers
    double policingRate = 4; // the rate at which tokens in the token bucket are generated
    double burstLength = 0.1; // the lnegth of the burst parameter of the token bucket
    int throttleUdp = 0; // 0 -> do not throttle, 1 -> otherwise
    int scenario = 0; // This is used to enable running different scenarios (e.g., congesion on non-common link)

    CommandLine cmd;
    cmd.AddValue("linkRate", "the rate of the common link", commonLinkRate);
    cmd.AddValue("duration", "the duration of the the simulation", duration);
    cmd.AddValue("resultsFolderName", "the name of the folder to save results to", resultsFolderName);
    cmd.AddValue("appProtocol", "the protocol used by the wehe app: 0=udp, 1=tcp", isTCP);
    cmd.AddValue("TCPProtocol", "the tcp congestion control protocol", tcpProtocol);
    cmd.AddValue("appType", "The measurement application to run", appType);
    cmd.AddValue("pktSize", "pktSize", pktSize);
    cmd.AddValue("lambda", "lambda", lambda);
    cmd.AddValue("replayTrace", "file to replay by the Client", replayTrace);
    cmd.AddValue("neutral", "to enable neutral bottleneck behaviour (0 means neutral)", isNeutral);
    cmd.AddValue("policingRate", "rate used in case of policing (in Mbps) ", policingRate);
    cmd.AddValue("policingBurstLength", "duration of burst (in sec)", burstLength);
    cmd.AddValue("throttleUdp", "0 to throttle udp traffic, 1 otherwise", throttleUdp);
    cmd.AddValue("scenario", "scenario to run (e.g., congesion on non-common link)", scenario);
    cmd.Parse(argc, argv);
    /*** end of defining inputs ***/

    srand(ns3::RngSeedManager::GetSeed());

    /*** Time Parameters ***/
    Time simStartTime = Seconds(0.);
    Time warmupTime = Seconds(10); // time before start sending measurement traffic to eliminate transient period
    Time simEndTime = warmupTime + Seconds(duration) + Seconds(5);

    /*** Input-Output parameters ***/
    string resultsPath = (string)(getenv("PWD")) + "/results" + resultsFolderName;
    string dataPath = (string)(getenv("PWD")) + "/data";

    /*** Topology Parameters ***/
    uint32_t nbApps = 4;
    uint32_t nbServers = nbApps + 1; // the +1 is for the last path which carries only back traffic (could be eliminated)


    /*** Traffic Parameters ***/
    string appProtocol = (isTCP == 1) ? "ns3::TcpSocketFactory" : "ns3::UdpSocketFactory";

    uint32_t rcvBufSize = 131072;//2e9;
    uint32_t sndBufSize = 131072;//2e9;
    uint32_t mss = 1228;
    uint32_t mtu = 1500;
    Config::SetDefault("ns3::TcpL4Protocol::SocketType", StringValue ("ns3::TcpCubic"));
    Config::SetDefault("ns3::TcpSocket::SegmentSize", UintegerValue (mss));
    Config::SetDefault("ns3::TcpSocket::RcvBufSize", UintegerValue (rcvBufSize));
    Config::SetDefault("ns3::TcpSocket::SndBufSize", UintegerValue (sndBufSize));
    Config::SetDefault("ns3::TcpSocket::DelAckCount", UintegerValue (1));
    Config::SetDefault("ns3::TcpSocketBase::MinRto", TimeValue (MilliSeconds(200)));
    Config::SetDefault("ns3::TcpL4Protocol::RecoveryType", TypeIdValue (TcpClassicRecovery::GetTypeId()));


    /*** Create the topology ***/
    NS_LOG_INFO("Create Topology.");
    NodeContainer routers; routers.Create(2); // router[0] is actually the mobile client
    NodeContainer serverNodes; serverNodes.Create(nbServers);

    InternetStackHelper internetStackHelper;
    internetStackHelper.Install(routers);
    internetStackHelper.Install(serverNodes);

    string defaultCommonDataRate = "10Gbps";
    string defaultNonCommonDataRate = "1Gbps";
    string defaultLinkDelay = "5ms";
    PointToPointHelper p2p;
    p2p.SetDeviceAttribute("Mtu", UintegerValue(mtu));
    p2p.SetQueue("ns3::DropTailQueue", "MaxSize", StringValue("1p"));


    NetDeviceContainer channels_r1_servers[nbServers];
    string delays[] = {defaultLinkDelay, defaultLinkDelay, defaultLinkDelay, defaultLinkDelay, defaultLinkDelay};
    string dataRates[] = {defaultNonCommonDataRate, defaultNonCommonDataRate, defaultNonCommonDataRate, defaultCommonDataRate, defaultCommonDataRate};

    if(scenario == 3) {
        delays[2] = "8ms";
    }
    else if(scenario == 4) {
        dataRates[2] = "100Mbps";
        dataRates[3] = "100Mbps";
    }
    else if(scenario == 5) {
        dataRates[2] = "100Mbps";
    }
    else if(scenario == 6) {
        dataRates[2] = "150Mbps";
        dataRates[3] = "100Mbps";
    }

    for(uint32_t i = 0; i < nbServers; i++) {
        p2p.SetDeviceAttribute("DataRate", StringValue(dataRates[i]));
        p2p.SetChannelAttribute("Delay", StringValue(delays[i]));
        channels_r1_servers[i] = p2p.Install(serverNodes.Get(i), routers.Get(1));

        string queueSize = to_string(0.02 * (DataRate(defaultNonCommonDataRate).GetBitRate() * 0.125)) + "B"; // RTT * link_rate

        // set the queues to fifo queueing discipline
        TrafficControlHelper tch;
        tch.SetRootQueueDisc("ns3::FifoQueueDisc", "MaxSize", StringValue(queueSize));
        tch.Install(channels_r1_servers[i]);

        // For the independent policers on non-common links
        if ((isNeutral == 3 || isNeutral == 4 || isNeutral == 5) && (i == 2 || i == 3)) {
            uint8_t linkTos = (isNeutral == 4 && i == 3) ? 8 : 4;

            int burst = floor(policingRate * burstLength * 125000);// in byte
            string subQueueSize = to_string(int(0.02 * ((DataRate(defaultNonCommonDataRate).GetBitRate() - policingRate * 1e6) * 0.125))) + "B";

            TrafficControlHelper policerTch;
            uint16_t handle2 = policerTch.SetRootQueueDisc("ns3::CbQueueDisc", "MaxSize", StringValue(queueSize),
                                                           "TosMap", TosMapValue(TosMap{0, linkTos}));
            TrafficControlHelper::ClassIdList cid2 = policerTch.AddQueueDiscClasses (handle2, 2, "ns3::QueueDiscClass");
            policerTch.AddChildQueueDisc (handle2, cid2[0], "ns3::FifoQueueDisc",
                                          "MaxSize", StringValue(subQueueSize));
            policerTch.AddChildQueueDisc (handle2, cid2[1], "ns3::TbfQueueDiscChild",
                                          "MaxSize", StringValue(to_string(burst) + "B"),
                                          "Burst", UintegerValue (burst),
                                          "Mtu", UintegerValue (mtu),
                                          "Rate", DataRateValue (DataRate (to_string(policingRate) + "Mbps")),
                                          "PeakRate", DataRateValue (DataRate ("0bps")),
                                          "ResultsFolder", StringValue(resultsPath + "/enqueued_events_policer4_path" + to_string(i) + ".csv"));

            const Ptr<NetDevice> &netDevice = serverNodes.Get(i)->GetDevice(1);
            tch.Uninstall(netDevice);
            policerTch.Install(netDevice);

        }
    }

    // Parameters for the common channel
    PointToPointHelper p2pRouters;
    p2pRouters.SetDeviceAttribute("DataRate", StringValue(commonLinkRate));
    p2pRouters.SetChannelAttribute("Delay", StringValue(defaultLinkDelay));
    p2pRouters.SetDeviceAttribute("Mtu", UintegerValue(mtu));
    p2pRouters.SetQueue("ns3::DropTailQueue", "MaxSize", StringValue("1p"));
    NetDeviceContainer channel_r0_r1 = p2pRouters.Install(routers.Get(0), routers.Get(1));


    // Modify the traffic control layer module of the router 0 net device to implement policing
    TrafficControlHelper tch;
    string queueSize = to_string(int(0.02 * (DataRate(commonLinkRate).GetBitRate() * 0.125))) + "B"; // RTT * link_rate
    tch.SetRootQueueDisc("ns3::FifoQueueDisc", "MaxSize", StringValue(queueSize));
    tch.Install(channel_r0_r1);

    if(isNeutral == 1 || isNeutral == 2) {
        int burst = floor(policingRate * burstLength * 125000); // in byte
        string subQueueSize = to_string(int(0.02 * ((DataRate(commonLinkRate).GetBitRate() - isNeutral * policingRate * 1e6) * 0.125))) + "B";

        TrafficControlHelper policerTch;
        uint16_t handle = policerTch.SetRootQueueDisc("ns3::CbQueueDisc", "MaxSize", StringValue(queueSize),
                                                            "TosMap", TosMapValue(TosMap{0, 4, 8}));

        TrafficControlHelper::ClassIdList cid = policerTch.AddQueueDiscClasses (handle, 3, "ns3::QueueDiscClass");
        policerTch.AddChildQueueDisc (handle, cid[0], "ns3::FifoQueueDisc", "MaxSize", StringValue(subQueueSize));
        policerTch.AddChildQueueDisc (handle, cid[1], "ns3::TbfQueueDiscChild",
                                       "MaxSize", StringValue(to_string(burst) + "B"),
                                       "Burst", UintegerValue (burst),
                                       "Mtu", UintegerValue (mtu),
                                       "Rate", DataRateValue (DataRate (to_string(policingRate) + "Mbps")),
                                       "PeakRate", DataRateValue (DataRate ("0bps")),
                                       "ResultsFolder", StringValue(resultsPath + "/enqueued_events_policer4.csv"));
        policerTch.AddChildQueueDisc (handle, cid[2], "ns3::TbfQueueDiscChild",
                                       "MaxSize", StringValue(to_string(burst) + "B"),
                                       "Burst", UintegerValue (burst),
                                       "Mtu", UintegerValue (mtu),
                                       "Rate", DataRateValue (DataRate (to_string(policingRate) + "Mbps")),
                                       "PeakRate", DataRateValue (DataRate ("0bps")),
                                       "ResultsFolder", StringValue(resultsPath + "/enqueued_events_policer8.csv"));

        const Ptr<NetDevice> &netDevice = routers.Get(1)->GetDevice(routers.Get(1)->GetNDevices() - 1);
        tch.Uninstall(netDevice);
        policerTch.Install(netDevice);
    }



    Ipv4AddressHelper ipv4;
    uint16_t nbSubnets = 0;
    ipv4.SetBase(("10.1." + to_string(++nbSubnets) + ".0").c_str(), "255.255.255.0");
    Ipv4InterfaceContainer addresses_r0_r1 = ipv4.Assign(channel_r0_r1);
    Ipv4InterfaceContainer addresses_dsts_r0[nbServers];
    Ipv4Address dstAddresses[nbServers];
    for(uint32_t i = 0; i < nbServers; i++) {
        ipv4.SetBase(("10.1." + to_string(++nbSubnets) + ".0").c_str(), "255.255.255.0");
        addresses_dsts_r0[i] = ipv4.Assign(channels_r1_servers[i]);
        dstAddresses[i] = addresses_dsts_r0[i].GetAddress(0);
    }

    Ipv4GlobalRoutingHelper::PopulateRoutingTables();


    uint16_t appPorts[nbApps];
    int trafficClass[] = {0, 0, 4, 4};
    if (isNeutral == 2 || isNeutral == 4) { trafficClass[3] = 8; }
    else if (isNeutral == 5) { trafficClass[2] = 0;}
    /*** Create Wehe Traffic ***/
    for(uint32_t i = 0; i < nbApps; i++) {
        // create the application at destination
        uint32_t sinkPort = 3001 + i;
        PacketSinkHelper sinkAppHelper(appProtocol, InetSocketAddress(Ipv4Address::GetAny (), sinkPort));
        ApplicationContainer sinkApp = sinkAppHelper.Install(routers.Get(0));
        sinkApp.Start(warmupTime);
        sinkApp.Stop(simEndTime);

        // create the client sending poisson
        InetSocketAddress sinkAddress = InetSocketAddress(addresses_r0_r1.GetAddress(0), sinkPort);
        sinkAddress.SetTos(trafficClass[i]); // used for policing to set the traffic type

        ApplicationContainer app;
        if (appType == 1 || appType == 2) {
            string intervalRV = (appType == 1) ?
                    "ns3::ConstantRandomVariable[Constant=" + to_string(lambda) + "]" :
                    "ns3::ExponentialRandomVariable[Mean=" + to_string(lambda) + "]";
            PoissonClientHelper poissonClientHelper(sinkAddress);
            poissonClientHelper.SetAttribute("Protocol", StringValue(appProtocol));
            poissonClientHelper.SetAttribute("Interval", StringValue(intervalRV));
            poissonClientHelper.SetAttribute("PacketSize", UintegerValue(pktSize));
            poissonClientHelper.SetAttribute("EnableCwndMonitor", BooleanValue(true));
            poissonClientHelper.SetAttribute("ResultsFolder", StringValue(resultsPath));
            app = poissonClientHelper.Install(serverNodes.Get(i));
        }
        else if (appType == 3) {
            MeasurReplayClientHelper replayClientHelper(sinkAddress);
            replayClientHelper.SetAttribute("Protocol", StringValue(appProtocol));
            replayClientHelper.SetAttribute("TraceFile", StringValue(dataPath + "/" + replayTrace));
            replayClientHelper.SetAttribute("EnableCwndMonitor", BooleanValue(true));
            replayClientHelper.SetAttribute("ResultsFolder", StringValue(resultsPath));
            app = replayClientHelper.Install(serverNodes.Get(i));
        }
        else if (appType == 4) {
            InfiniteTCPClientHelper infiniteTcpClientHelper(sinkAddress);
            infiniteTcpClientHelper.SetAttribute("PacketSize", UintegerValue(pktSize));
            infiniteTcpClientHelper.SetAttribute("TcpProtocol", StringValue(tcpProtocol));
            infiniteTcpClientHelper.SetAttribute("EnableCwndMonitor", BooleanValue(true));
            infiniteTcpClientHelper.SetAttribute("ResultsFolder", StringValue(resultsPath));
            app = infiniteTcpClientHelper.Install(serverNodes.Get(i));
        }
        app.Start(warmupTime);
        app.Stop(warmupTime + Seconds(duration));

        // for the packet monitoring
        appPorts[i] = sinkPort;
    }

    /*** Create Background Traffic ***/
//    MultipleReplayClients* back = new MultipleReplayClients(serverNodes.Get(nbServers-1), routers.Get(0));
////    back->RunAllTraces(dataPath + "/chicago_2010_back_traffic_10min", 3173, 1, 0);
//    // adjust them so that some of them can be throttled
//    double throttledProb = (isNeutral == 1) ? 0.4 : 0;
//    string tracesPath = dataPath + "/chicago_2010_back_traffic_5min_control_cbp";
//    runRandomControlAndThrottledTraffic(back, tracesPath, 3281, throttledProb, 4);



    /*** Create Cross Traffic On Paths 3 & 4 ***/
    bool splitUdp = (throttleUdp == 1);

    MultipleReplayClients* backP2 = new MultipleReplayClients(serverNodes.Get(2), routers.Get(0));
    double throttledProbP2 = (isNeutral == 1 || isNeutral == 3 || isNeutral == 5) ? 0.4 : 0;
    string tracesPathP2 = dataPath + "/chicago_2010_back_traffic_5min_control_cbp_2links/link0";
    runRandomControlAndThrottledTraffic(backP2, tracesPathP2, 1668, throttledProbP2, 4, splitUdp);

    MultipleReplayClients* backP3 = new MultipleReplayClients(serverNodes.Get(3), routers.Get(0));
    double throttledProbP3 = (isNeutral == 1 || isNeutral == 3 || isNeutral == 5) ? 0.4 : 0;
    string tracesPathP3 = dataPath + "/chicago_2010_back_traffic_5min_control_cbp_2links/link1";
    runRandomControlAndThrottledTraffic(backP3, tracesPathP3, 1649, throttledProbP3, 4, splitUdp);



#if PCAP_FLAG /*** Record Pcap files for channels ***/
    AsciiTraceHelper ascii;
//    p2p.EnableAsciiAll(ascii.CreateFileStream(resultsPath + "/tracing.tr"));
    p2pRouters.EnablePcapAll(resultsPath + "/pcap_files");
//    p2pRouters.EnablePcap(resultsPath + "/router-link", 0, 1);
#endif

    uint32_t routersIds[2] = {routers.Get(0)->GetId(), routers.Get(1)->GetId()};
    uint32_t dstIds[nbServers]; for(uint32_t i = 0; i < nbServers; i++) { dstIds[i] = serverNodes.Get(i)->GetId(); }

#if PACKET_MONITOR_FLAG
    PacketMonitor* bottleneckPktMonitorDown = new PacketMonitor(warmupTime, Seconds(duration), routersIds[1], routersIds[0], "bottleneckDown");
    for(uint32_t i = 0; i < nbApps; i++)
        bottleneckPktMonitorDown->AddAppKey(dstAddresses[i], addresses_r0_r1.GetAddress(0), 0, 0);

    vector<PacketMonitor*> pathPktsMonitorsDown;
    for(uint32_t i = 0; i < nbApps; i++) {
        PacketMonitor* pathMonitor = new PacketMonitor(warmupTime, Seconds(duration), dstIds[i], routersIds[0],  "path" + to_string(i) + "Down");
        pathMonitor->AddAppKey(dstAddresses[i], addresses_r0_r1.GetAddress(0), 0, appPorts[i]);
        pathPktsMonitorsDown.push_back(pathMonitor);
    }

//    vector<PacketMonitor*> pathPktsMonitorsUp;
//    for(uint32_t i = 0; i < nbApps; i++) {
//        PacketMonitor* pathMonitor = new PacketMonitor(warmupTime, Seconds(duration), routersIds[0], dstIds[i],  "path" + to_string(i) + "Up");
//        pathMonitor->AddAppKey(addresses_r0_r1.GetAddress(0), dstAddresses[i],  appPorts[i], 0);
//        pathPktsMonitorsUp.push_back(pathMonitor);
//    }

#endif

    /*** Run simulation ***/
    NS_LOG_INFO("Run Simulation.");
    Simulator::Stop(simEndTime);
    Simulator::Run();
    Simulator::Destroy();
    NS_LOG_INFO("Done.");


#if PACKET_MONITOR_FLAG
    bottleneckPktMonitorDown->SaveRecordedPacketsCompact(resultsPath + "/bottleneck_packets_down.csv");
    for(uint32_t i = 0; i < nbApps; i++) {
        pathPktsMonitorsDown[i]->SaveRecordedPacketsCompact(resultsPath + "/path" + to_string(i) + "_packets_down.csv");
//        pathPktsMonitorsDownsUp[i]->SaveRecordedPacketsCompact(resultsPath + "/path" + to_string(i) + "_packets_up.csv");
    }
#endif

    auto stop = high_resolution_clock::now();
    cout << "Total execution time = " << duration_cast<microseconds>(stop - start).count() << " microsecond" << endl;

    return 0;
}


