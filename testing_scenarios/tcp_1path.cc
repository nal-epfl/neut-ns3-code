//
// Created by nal on 22.12.20.
//
// Network topology
//
//       r0 --- r1
//
// - Single Infinite TCP flow form r0 to r1

#include <iostream>
#include <string>

#include "ns3/core-module.h"
#include "ns3/network-module.h"
#include "ns3/point-to-point-module.h"
#include "ns3/applications-module.h"
#include "ns3/internet-module.h"
#include "ns3/ipv4-global-routing-helper.h"
#include "ns3/traffic-control-module.h"

#include "ns3/netanim-module.h"
#include "ns3/flow-monitor-module.h"
#include "ns3/file-helper.h"

#include "../monitors_module/PacketMonitor.h"

#include "../traffic_generator_module/trace_replay/TraceReplayClientServer.h"
#include "../traffic_generator_module/ppb/PPBBidirectional.h"

#include "../traffic_differentiation_module/CbQueueDisc.h"
#include "../helper_classes/HelperMethods.h"
#include "../traffic_generator_module/infinite_tcp/InfiniteTCPClientHelper.h"


using namespace ns3;
using namespace std;

NS_LOG_COMPONENT_DEFINE("1PathTCP");

#define PCAP_FLAG 1

/*****************************************************************************/
int run_1path_tcp(int argc, char **argv) {

    LogComponentEnable ("1PathTCP", LOG_LEVEL_INFO);
    NS_LOG_INFO("TCP Flow is running on single path");

    /*** Variables read from arguments ***/
    string linkRate = "180Mbps"; // the transmission rate of the common link
    string linkDelay = "10ms"; // link propagation delay
    float duration = 120.; // for how long measurement traffic should run
    string resultsFolderName; // the output folder to save files generated by the monitors
    string tcpProtocol = "ns3::TcpCubic"; // in case of TCP the congestion control algorithm to use
    uint32_t pktSize = 256; // size of probe packets
    int isNeutral = 0; // 0 to Run a neutral appType
    double policingRate = 4; // the rate at which tokens in the token bucket are generated
    double burstLength = 0.1; // the lnegth of the burst parameter of the token bucket

    CommandLine cmd;
    cmd.AddValue("linkRate", " the rate of the link", linkRate);
    cmd.AddValue("duration", "the duration of the the simulation", duration);
    cmd.AddValue("resultsFolderName", " the name of the folder to save results to", resultsFolderName);
    cmd.AddValue("TCPProtocol", "the tcp congestion control protocol", tcpProtocol);
    cmd.AddValue("pktSize", "pktSize", pktSize);
    cmd.AddValue("neutral", "to enable neutral bottleneck behaviour (0 means neutral)", isNeutral);
    cmd.AddValue("policingRate", "rate used in case of policing (in Mbps) ", policingRate);
    cmd.AddValue("policingBurstLength", "duration of burst (in sec)", burstLength);
    cmd.Parse(argc, argv);

    srand(ns3::RngSeedManager::GetSeed());

    /*** Time Parameters ***/
    Time testStartTime = Seconds(0.);
    Time testEndTime = testStartTime + Seconds(duration);

    /*** Input-Output parameters ***/
    string resultsPath = (string)(getenv("PWD")) + "/results/" + resultsFolderName;
    string dataPath = (string)(getenv("PWD")) + "/data/";

    /*** Traffic Parameters ***/
    string appProtocol =  "ns3::TcpSocketFactory";

    uint32_t rcvBufSize = 131072, sndBufSize = 131072;
    uint32_t mss = 1228, mtu = 1500;
    Config::SetDefault("ns3::TcpL4Protocol::SocketType", StringValue ("ns3::TcpNewReno"));
    Config::SetDefault("ns3::TcpSocket::SegmentSize", UintegerValue (mss));
    Config::SetDefault("ns3::TcpSocket::RcvBufSize", UintegerValue (rcvBufSize));
    Config::SetDefault("ns3::TcpSocket::SndBufSize", UintegerValue (sndBufSize));
    Config::SetDefault("ns3::TcpSocket::DelAckCount", UintegerValue(1));
    Config::SetDefault("ns3::TcpSocketBase::MinRto", TimeValue(MilliSeconds(200)));
    Config::SetDefault("ns3::TcpL4Protocol::RecoveryType", TypeIdValue(TcpClassicRecovery::GetTypeId()));
//    Config::SetDefault ("ns3::TcpSocketState::EnablePacing", BooleanValue (true));

    /*** Create the dumbbell topology ***/
    NS_LOG_INFO("Create Topology.");
    NodeContainer nodes; nodes.Create(2);

    InternetStackHelper internetStackHelper;
    internetStackHelper.Install(nodes);

    // Parameters for the channel
    PointToPointHelper p2pRouters;
    p2pRouters.SetDeviceAttribute("DataRate", StringValue(linkRate));
    p2pRouters.SetChannelAttribute("Delay", StringValue(linkDelay));
    p2pRouters.SetDeviceAttribute("Mtu", UintegerValue(mtu));
    p2pRouters.SetQueue("ns3::DropTailQueue", "MaxSize", StringValue("1p"));
    NetDeviceContainer channel_r0_r1 = p2pRouters.Install(nodes.Get(0), nodes.Get(1));

    // Modify the traffic control layer module of the node 0 net device to implement policing
//    TrafficControlHelper tch;
//    string queueSize = HelperMethods::ComputeQueueSize(linkRate, {linkDelay});
//    tch.SetRootQueueDisc("ns3::FifoQueueDisc", "MaxSize", StringValue(queueSize));
//    tch.Install(channel_r0_r1);
//    if (!isNeutral) {
//        TrafficControlHelper policerTch = CbQueueDisc::GenerateDisc1FifoNPolicers(
//                queueSize, {0, 4}, policingRate, burstLength, resultsPath + "/link");
//
//        const Ptr<NetDevice> &netDevice = nodes.Get(1)->GetDevice(nodes.Get(1)->GetNDevices() - 1);
//        tch.Uninstall(netDevice);
//        policerTch.Install(netDevice);
//    }


    Ipv4AddressHelper ipv4;
    ipv4.SetBase(("10.1.1.0"), "255.255.255.0");
    Ipv4InterfaceContainer addresses_r0_r1 = ipv4.Assign(channel_r0_r1);


    Ipv4GlobalRoutingHelper::PopulateRoutingTables();

    /*** Create Measurement Traffic ***/
    const Ptr<Node> &sender = nodes.Get(0), receiver = nodes.Get(1);
    AppKey appKey(HelperMethods::GetNodeIP(sender, 1), HelperMethods::GetNodeIP(receiver, 1), 0, 3001);

    PacketSinkHelper sinkAppHelper(appProtocol, InetSocketAddress(Ipv4Address::GetAny(), appKey.GetDstPort()));
    ApplicationContainer sinkApp = sinkAppHelper.Install(receiver);
    sinkApp.Start(testStartTime);
    sinkApp.Stop(testEndTime);

    InetSocketAddress sinkAddress = InetSocketAddress(appKey.GetDstIp(), appKey.GetDstPort());
    sinkAddress.SetTos(4); // used for policing to set the traffic type
    ApplicationContainer app = InfiniteTCPClientHelper::CreateInfiniteTcpApplication(sinkAddress, tcpProtocol, pktSize,
                                                                                     resultsPath, sender, "20Mbps");
    app.Start(testStartTime);
    app.Stop(testEndTime);


#if PCAP_FLAG /*** Record Pcap files for channels ***/
    AsciiTraceHelper ascii;
//    p2pRouters.EnableAsciiAll(ascii.CreateFileStream(resultsPath + "/tracing.tr"));
    p2pRouters.EnablePcapAll(resultsPath + "/router-link");
#endif

    auto* appMonitor = new PacketMonitor(testStartTime, testEndTime, sender->GetId(), receiver->GetId(), "app0");
    appMonitor->AddAppKey(appKey);

    /*** Run simulation ***/
    NS_LOG_INFO("Run Simulation.");
    Simulator::Stop(testEndTime + Seconds(5));
    Simulator::Run();
    Simulator::Destroy();
    NS_LOG_INFO("Done.");

    appMonitor->SaveRecordedPacketsCompact(resultsPath + "/app0_packets.csv");

    return 0;
}
